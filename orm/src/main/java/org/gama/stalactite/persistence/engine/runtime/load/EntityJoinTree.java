package org.gama.stalactite.persistence.engine.runtime.load;

import javax.annotation.Nullable;
import java.util.ArrayDeque;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Queue;
import java.util.Set;
import java.util.function.BiFunction;
import java.util.function.Consumer;
import java.util.function.Function;

import org.gama.lang.Reflections;
import org.gama.lang.collection.ReadOnlyList;
import org.gama.stalactite.persistence.engine.runtime.BeanRelationFixer;
import org.gama.stalactite.persistence.mapping.ColumnedRow;
import org.gama.stalactite.persistence.mapping.IEntityMappingStrategy;
import org.gama.stalactite.persistence.mapping.IRowTransformer;
import org.gama.stalactite.persistence.structure.Column;
import org.gama.stalactite.persistence.structure.Table;
import org.gama.stalactite.sql.result.Row;

/**
 * Tree representing joins of a from clause, nodes are {@link JoinNode}.
 * It maintains an index of its joins based on an unique name for each, so they can be refrenced outside of {@link EntityJoinTree} and without
 * depending on classes of this package (since the reference is a {@link String}). 
 * 
 * @author Guillaume Mary
 */
public class EntityJoinTree<C, I> {
	
	/** Key of the very first {@link EntityJoinTree} added to the join structure (the one generated by constructor), see {@link #getRoot()} */
	public static final String ROOT_STRATEGY_NAME = "ROOT";
	
	private final JoinRoot<C, I, ?> root;
	
	/**
	 * A mapping between a name and a join to help finding them when we want to join one with another new one
	 * @see #addRelationJoin(String, EntityInflater, Column, Column, JoinType, BeanRelationFixer) 
	 */
	private final Map<String, JoinNode> joinIndex = new HashMap<>();
	
	/**
	 * The objet that will help to give names of strategies into the index (no impact on the generated SQL)
	 */
	private final StrategyIndexNamer indexNamer = new StrategyIndexNamer();
	
	public EntityJoinTree(JoinRoot<C, I, ?> root) {
		this.root = root;
		this.joinIndex.put(ROOT_STRATEGY_NAME, root);
	}
	
	public JoinRoot<C, I, ?> getRoot() {
		return root;
	}
	
	/**
	 * Adds a join to this select.
	 * Use for one-to-one or one-to-many cases when join is used to describe a related bean. 
	 *
	 * @param <U> type of bean mapped by the given strategy
	 * @param <T1> joined left table
	 * @param <T2> joined right table
	 * @param <ID> type of joined values
	 * @param leftStrategyName the name of a (previously) registered join. {@code leftJoinColumn} must be a {@link Column} of its left {@link Table}
	 * @param inflater the strategy of the mapped bean. Used to give {@link Column}s and {@link IRowTransformer}
	 * @param leftJoinColumn the {@link Column} (of previous strategy left table) to be joined with {@code rightJoinColumn}
	 * @param rightJoinColumn the {@link Column} (of the strategy table) to be joined with {@code leftJoinColumn}
	 * @param joinType says wether or not the join must be open
	 * @param beanRelationFixer a function to fullfill relation between 2 strategies beans
	 * @return the name of the created join, to be used as a key for other joins (through this method {@code leftStrategyName} argument)
	 */
	public <U, T1 extends Table<T1>, T2 extends Table<T2>, ID> String addRelationJoin(String leftStrategyName,
																					  EntityInflater<U, ID, T2> inflater,
																					  Column<T1, ID> leftJoinColumn,
																					  Column<T2, ID> rightJoinColumn,
																					  JoinType joinType,
																					  BeanRelationFixer<C, U> beanRelationFixer) {
		return this.<T1>addJoin(leftStrategyName, parent -> new RelationJoinNode<>(
				parent,
				leftJoinColumn, rightJoinColumn, joinType,
				inflater.getSelectableColumns(), null, inflater, beanRelationFixer));
	}
	
	/**
	 * Adds a join to this select.
	 * Use for inheritance cases when joined data are used to complete an existing bean. 
	 *
	 * @param <U> type of bean mapped by the given strategy
	 * @param <T1> left table type
	 * @param <T2> right table type
	 * @param <ID> type of joined values
	 * @param leftStrategyName the name of a (previously) registered join. {@code leftJoinColumn} must be a {@link Column} of its left {@link Table}.
	 * 						Right table data will be merged with this "root".
	 * @param inflater the strategy of the mapped bean. Used to give {@link Column}s and {@link IRowTransformer}
	 * @param leftJoinColumn the {@link Column} (of previous strategy left table) to be joined with {@code rightJoinColumn}
	 * @param rightJoinColumn the {@link Column} (of the strategy table) to be joined with {@code leftJoinColumn}
	 * @return the name of the created join, to be used as a key for other joins (through this method {@code leftStrategyName} argument)
	 */
	public <U, T1 extends Table<T1>, T2 extends Table<T2>, ID> String addMergeJoin(String leftStrategyName,
																				   EntityMerger<U, T2> inflater,
																				   Column<T1, ID> leftJoinColumn,
																				   Column<T2, ID> rightJoinColumn) {
		return this.<T1>addJoin(leftStrategyName, parent -> new MergeJoinNode<>(parent,
				leftJoinColumn, rightJoinColumn, JoinType.INNER,
				null, inflater));
	}
	
	/**
	 * Adds a merge join to this select : no bean will be created by given {@link EntityInflater}, only its
	 * {@link org.gama.stalactite.persistence.mapping.AbstractTransformer#applyRowToBean(Row, Object)} will be used during bean graph loading process.
	 *
	 * @param <T1> left table type
	 * @param <T2> right table type
	 * @param <ID> type of joined values
	 * @param leftStrategyName join name on which join must be created
	 * @param inflater strategy to be used to load bean
	 * @param leftJoinColumn left join column, expected to be one of left strategy table
	 * @param rightJoinColumn right join column
	 * @param joinType type of join to create
	 * @return the name of the created join, to be used as a key for other joins (through this method {@code leftStrategyName} argument)
	 */
	public <U, T1 extends Table<T1>, T2 extends Table<T2>, ID> String addMergeJoin(String leftStrategyName,
																				   EntityMerger<U, T2> inflater,
																				   Column<T1, ID> leftJoinColumn,
																				   Column<T2, ID> rightJoinColumn,
																				   JoinType joinType) {
		return this.<T1>addJoin(leftStrategyName, parent -> new MergeJoinNode<>(parent,
				leftJoinColumn, rightJoinColumn, joinType,
				null, inflater));
	}
	
	/**
	 * Adds a passive join to this select : this kind if join doesn't take part to bean construction, it aims only at adding an SQL join to
	 * bean graph loading.
	 *
	 * @param leftStrategyName join name on which join must be created
	 * @param leftJoinColumn left join column, expected to be one of left strategy table
	 * @param rightJoinColumn right join column
	 * @param joinType type of join to create
	 * @param columnsToSelect columns that must be added to final select
	 * @param <T1> left table type
	 * @param <T2> right table type
	 * @param <ID> type of joined values
	 * @return the name of the created join, to be used as a key for other joins (through this method {@code leftStrategyName} argument)
	 */
	public <T1 extends Table<T1>, T2 extends Table<T2>, ID> String addPassiveJoin(String leftStrategyName,
																				  Column<T1, ID> leftJoinColumn,
																				  Column<T2, ID> rightJoinColumn,
																				  JoinType joinType,
																				  Set<Column<T2, Object>> columnsToSelect) {
		return this.<T1>addJoin(leftStrategyName, parent -> new PassiveJoinNode<>(parent,
				leftJoinColumn, rightJoinColumn, joinType,
				columnsToSelect, null));
	}
	
	private <T extends Table> String addJoin(String leftStrategyName, Function<JoinNode<T> /* parent node */, AbstractJoinNode> joinNodeSupplier) {
		JoinNode<T> owningJoin = getJoin(leftStrategyName);
		if (owningJoin == null) {
			throw new IllegalArgumentException("No strategy with name " + leftStrategyName + " exists to add a new strategy on");
		}
		AbstractJoinNode joinNode = joinNodeSupplier.apply(owningJoin);
		String joinName = this.indexNamer.generateName(joinNode);
		this.joinIndex.put(joinName, joinNode);
		return joinName;
	}
	
	/**
	 * Gives a particular node of the joins graph by its name. Joins graph name are given in return of
	 * {@link #addRelationJoin(String, EntityInflater, Column, Column, JoinType, BeanRelationFixer)}.
	 * When {@link #ROOT_STRATEGY_NAME} is given, {@link #getRoot()} will be used, meanwhile, be aware that using this method to retreive root node
	 * is not the recommanded way : prefer usage of {@link #getRoot()} to prevent exposure of {@link #ROOT_STRATEGY_NAME}
	 *
	 * @param leftStrategyName join node name to be given
	 * @return null if the node doesn't exist
	 * @see #getRoot()
	 */
	@Nullable
	public <T extends Table> JoinNode<T> getJoin(String leftStrategyName) {
		return (JoinNode<T>) this.joinIndex.get(leftStrategyName);
	}
	
	/**
	 * Gives all tables used by this tree
	 *
	 * @return all joins tables of this tree
	 */
	public Set<Table> giveTables() {
		// because Table implements an hashCode on their name, we can use an HashSet to avoid duplicates
		Set<Table> result = new HashSet<>();
		result.add(root.getTable());
		foreachJoin(node -> result.add(node.getTable()));
		return result;
	}
	
	/**
	 * Goes down this tree by depth first. Made to avoid everyone implements node iteration.
	 * Consumer is invoked foreach node <strong>except root</strong> because it usually has a special treatment. 
	 * Traversal is made in pre-order : node is consumed first then its children.
	 * 
	 * @param consumer a {@link AbstractJoinNode} consumer
	 */
	public void foreachJoin(Consumer<AbstractJoinNode> consumer) {
		Queue<AbstractJoinNode> stack = new ArrayDeque<>(this.root.getJoins());
		while (!stack.isEmpty()) {
			AbstractJoinNode joinNode = stack.poll();
			consumer.accept(joinNode);
			stack.addAll(joinNode.getJoins());
		}
	}
	
	public <E, ID> void projectTo(EntityJoinTree<E, ID> target, String rootStrategyName) {
		projectTo(target.getJoin(rootStrategyName));
	}
	
	public void projectTo(JoinNode joinNode) {
		foreachJoinWithDepth(joinNode, (targetOwner, currentNode) -> {
			// cloning each node, the only difference lays on left column : target gets its matching column 
			Column projectedLeftColumn = targetOwner.getTable().getColumn(currentNode.getLeftJoinColumn().getName());
			if (projectedLeftColumn == null) {
				throw new IllegalArgumentException("Expected column "
						+ currentNode.getLeftJoinColumn().getAbsoluteName() + " to exist in target table " + targetOwner.getTable().getName());
			}
			return copyNode(targetOwner, currentNode, projectedLeftColumn);
			
		});
	}
	
	/**
	 * Goes down this tree by depth first.
	 * Consumer is invoked foreach node <strong>except root</strong> because it usually has a special treatment. 
	 * Used to create an equivalent tree of this instance with another type of node. This generally requires to know current parent so a child can
	 * be added to it : consumer gets current parent as a first argument
	 * 
	 * @param initialNode very first parent given as first argument to consumer
	 * @param consumer producer of target tree node, gets node of this tree and parent node of target tree to add created node to it
	 * @param <S> type of node of the equivalent tree
	 */
	<S> void foreachJoinWithDepth(S initialNode, BiFunction<S, AbstractJoinNode, S> consumer) {
		Queue<S> targetPath = new ArrayDeque<>();
		targetPath.add(initialNode);
		Queue<AbstractJoinNode> joinStack = new ArrayDeque<>(this.root.getJoins());
		while (!joinStack.isEmpty()) {
			AbstractJoinNode currentNode = joinStack.poll();
			
			S targetOwner = targetPath.peek();
			S nodeClone = consumer.apply(targetOwner, currentNode);
			
			ReadOnlyList<AbstractJoinNode> nextJoins = currentNode.getJoins();
			if (!nextJoins.isEmpty()) {
				joinStack.addAll(nextJoins);
				targetPath.add(nodeClone);
			}
			// if depth changes, we must remove target depth
			AbstractJoinNode nextIterationNode = joinStack.peek();
			if (nextIterationNode != null && nextIterationNode.getParent() != currentNode.getParent()) {
				targetPath.remove();
			}
		}
		
	}
	
	/**
	 * Clones given node.
	 * Could have been implemented by each node class itself but since this behavior is required only by the tree and a particular algorithm, decision
	 * mas made to do it outside of them.
	 * 
	 * @param parent parent node target of the clone
	 * @param node node to be cloned
	 * @param leftColumn column to be used as the left one of the new node
	 * @return a copy of given node, put as child of parent, using leftColumn
	 */
	private AbstractJoinNode copyNode(JoinNode parent, AbstractJoinNode node, Column leftColumn) {
		AbstractJoinNode nodeCopy;
		if (node instanceof RelationJoinNode) {
			nodeCopy = new RelationJoinNode<>(
					parent,
					leftColumn,
					node.getRightJoinColumn(),
					node.getJoinType(),
					node.getColumnsToSelect(),
					node.getTableAlias(),
					((RelationJoinNode<?, ?, ?, ?>) node).getEntityInflater(),
					((RelationJoinNode<?, ?, ?, ?>) node).getBeanRelationFixer());
		} else if (node instanceof MergeJoinNode) {
			nodeCopy = new MergeJoinNode<>(
					parent,
					leftColumn,
					node.getRightJoinColumn(),
					node.getJoinType(),
					node.getTableAlias(),
					((MergeJoinNode<?, ?, ?, ?>) node).getMerger());
		} else if (node instanceof PassiveJoinNode) {
			nodeCopy = new PassiveJoinNode<>(
					parent,
					leftColumn,
					node.getRightJoinColumn(),
					node.getJoinType(),
					node.getColumnsToSelect(),
					node.getTableAlias())
					.setTransformerListener(((PassiveJoinNode<?, ?, ?, ?>) node).getTransformerListener());
		} else {
			throw new UnsupportedOperationException("Unexpected type of join : some algorithm as change, please implement it here or fix it : "
					+ Reflections.toString(node.getClass()));
		}
		return nodeCopy;
	}
	
	private static class StrategyIndexNamer {
		
		private int aliasCount = 0;
		
		private String generateName(JoinNode classMappingStrategy) {
			// Note that this naming strategy could be more chaotic (random) since names are only here to give a unique identifier to joins then
			// joins can be referenced outside of this class. It could also be smarter (depending on concrete node class for instance) to ease debugging
			return classMappingStrategy.getTable().getAbsoluteName() + aliasCount++;
		}
	}
	
	/**
	 * Constract to deserialize a database row to a bean
	 *
	 * @param <E>
	 * @param <I>
	 */
	public interface EntityInflater<E, I, T extends Table> {
		
		Class<E> getEntityType();
		
		I giveIdentifier(Row row, ColumnedRow columnedRow);
		
		IRowTransformer<E> copyTransformerWithAliases(ColumnedRow columnedRow);
		
		Set<Column<T, Object>> getSelectableColumns();
		
		/**
		 * Adapter of a {@link IEntityMappingStrategy} as a {@link EntityInflater}.
		 * Implemented as a simple wrapper of a {@link IEntityMappingStrategy} because methods are very close.
		 * 
		 * @param <E> entity type
		 * @param <I> identifier type
		 * @param <T> table type
		 */
		class EntityMappingStrategyAdapter<E, I, T extends Table> implements EntityInflater<E, I, T> {
			
			private final IEntityMappingStrategy<E, I, T> delegate;
			
			public EntityMappingStrategyAdapter(IEntityMappingStrategy<E, I, T> delegate) {
				this.delegate = delegate;
			}
			
			@Override
			public Class<E> getEntityType() {
				return this.delegate.getClassToPersist();
			}
			
			@Override
			public I giveIdentifier(Row row, ColumnedRow columnedRow) {
				return this.delegate.getIdMappingStrategy().getIdentifierAssembler().assemble(row, columnedRow);
			}
			
			@Override
			public IRowTransformer<E> copyTransformerWithAliases(ColumnedRow columnedRow) {
				return this.delegate.copyTransformerWithAliases(columnedRow);
			}
			
			@Override
			public Set<Column<T, Object>> getSelectableColumns() {
				return this.delegate.getSelectableColumns();
			}
		}
		
	}
	
	/**
	 * Contract to merge a row to some bean property (no bean creation, only property completion)
	 * 
	 * @param <E>
	 * @param <T>
	 */
	public interface EntityMerger<E, T extends Table> {
		
		IRowTransformer<E> copyTransformerWithAliases(ColumnedRow columnedRow);
		
		Set<Column<T, Object>> getSelectableColumns();
		
		/**
		 * Adapter of a {@link IEntityMappingStrategy} as a {@link EntityMerger}.
		 * Implemented as a simple wrapper of a {@link IEntityMappingStrategy} because methods are very close.
		 *
		 * @param <E> entity type
		 * @param <T> table type
		 */
		class EntityMergerAdapter<E, T extends Table> implements EntityMerger<E, T> {
			
			private final IEntityMappingStrategy<E, ?, T> delegate;
			
			public EntityMergerAdapter(IEntityMappingStrategy<E, ?, T> delegate) {
				this.delegate = delegate;
			}
			
			@Override
			public IRowTransformer<E> copyTransformerWithAliases(ColumnedRow columnedRow) {
				return delegate.copyTransformerWithAliases(columnedRow);
			}
			
			@Override
			public Set<Column<T, Object>> getSelectableColumns() {
				return delegate.getSelectableColumns();
			}
		}
		
	}
	
	public enum JoinType {
		INNER,
		OUTER
	}
	
}

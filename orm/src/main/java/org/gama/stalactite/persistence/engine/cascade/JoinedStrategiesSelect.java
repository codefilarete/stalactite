package org.gama.stalactite.persistence.engine.cascade;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Set;
import java.util.function.Function;

import org.gama.lang.Strings;
import org.gama.stalactite.persistence.engine.BeanRelationFixer;
import org.gama.stalactite.persistence.engine.cascade.JoinedStrategiesSelect.StrategyJoins.RelationJoin;
import org.gama.stalactite.persistence.mapping.ClassMappingStrategy;
import org.gama.stalactite.persistence.mapping.IEntityMappingStrategy;
import org.gama.stalactite.persistence.structure.Column;
import org.gama.stalactite.persistence.structure.Table;
import org.gama.stalactite.query.model.From;
import org.gama.stalactite.query.model.Query;
import org.gama.stalactite.sql.binder.ParameterBinder;
import org.gama.stalactite.sql.binder.ParameterBinderProvider;

import static org.gama.stalactite.query.model.From.AbstractJoin.JoinDirection.INNER_JOIN;
import static org.gama.stalactite.query.model.From.AbstractJoin.JoinDirection.LEFT_OUTER_JOIN;

/**
 * Class that eases the creation of a SQL selection with multiple joined {@link ClassMappingStrategy}.
 * The representation of a link between strategies is done through {@link StrategyJoins}.
 * 
 * Joins have a name (very first one is {@value #FIRST_STRATEGY_NAME}, see {@link #FIRST_STRATEGY_NAME}) so one can reference it in further
 * joins for joining a table multiple times.
 *
 * @author Guillaume Mary
 * @see #buildSelectQuery()
 */
public class JoinedStrategiesSelect<C, I, T extends Table> {
	
	/** Key of the very first {@link StrategyJoins} added to the join structure (the one generated by constructor), see {@link #getJoinsRoot()} */
	public static final String FIRST_STRATEGY_NAME = "ROOT";
	
	/** Mappig between column name in select and their {@link ParameterBinder} for reading */
	private final Map<String, ParameterBinder> selectParameterBinders = new HashMap<>();
	/** Aliases of columns. Values are keys of {@link #selectParameterBinders} */
	private final Map<Column, String> aliases = new HashMap<>();
	/** Will give the {@link ParameterBinder} for the reading of the final select clause */
	private final ParameterBinderProvider<Column> parameterBinderProvider;
	/** The very first {@link ClassMappingStrategy} on which other strategies will be joined */
	private final StrategyJoins<C, I> root;
	/**
	 * A mapping between a name and join to help finding them when we want to join them with a new one
	 * @see #addRelationJoin(String, IEntityMappingStrategy, Column, Column, boolean, BeanRelationFixer) 
	 */
	private final Map<String, AbstractJoin> strategyIndex = new HashMap<>();
	/** The objet that will help to give names of strategies into the index (no impact on the generated SQL) */
	private final StrategyIndexNamer indexNamer = new StrategyIndexNamer();
	
	private ColumnAliasBuilder columnAliasBuilder = new ColumnAliasBuilder();
	
	/**
	 * Main constructor which gives the very first strategy name as {@value #FIRST_STRATEGY_NAME} (see {@link #FIRST_STRATEGY_NAME})
	 *
	 * @param classMappingStrategy the root strategy, added strategy will be joined wih it
	 * @param parameterBinderProvider the objet that will give {@link ParameterBinder} to read the selected columns
	 */
	public JoinedStrategiesSelect(IEntityMappingStrategy<C, I, T> classMappingStrategy, ParameterBinderProvider<Column> parameterBinderProvider) {
		this(classMappingStrategy, parameterBinderProvider, FIRST_STRATEGY_NAME);
	}
	
	/**
	 * Constructor that let one gives the very first strategy name.
	 *
	 * @param classMappingStrategy the root strategy, added strategy will be joined wih it
	 * @param parameterBinderProvider the objet that will give {@link ParameterBinder} to read the selected columns
	 * @param strategyName the very first strategy name
	 */
	JoinedStrategiesSelect(IEntityMappingStrategy<C, I, T> classMappingStrategy, ParameterBinderProvider<Column> parameterBinderProvider, String strategyName) {
		this.parameterBinderProvider = parameterBinderProvider;
		this.root = new StrategyJoins<>(classMappingStrategy);
	}
	
	public Map<String, ParameterBinder> getSelectParameterBinders() {
		return selectParameterBinders;
	}
	
	/**
	 * @return the generated aliases by {@link Column} during the {@link #addColumnsToSelect(String, Iterable, Query)} phase
	 */
	public Map<Column, String> getAliases() {
		return aliases;
	}
	
	public String getAlias(Column column) {
		return aliases.get(column);
	}
	
	/**
	 * Give the root of all joins needed by the strategy to build its entity graph at load time and persist it.  
	 * @return a {@link StrategyJoins} which is the root of the graph, which {@link ClassMappingStrategy} is the one given at construction time of this instance
	 */
	public StrategyJoins<C, I> getJoinsRoot() {
		return root;
	}
	
	
	/**
	 * Gives a particular node of the joins graph by its name. Joins graph name are given in return of
	 * {@link #addRelationJoin(String, IEntityMappingStrategy, Column, Column, boolean, BeanRelationFixer)}.
	 * Prefer usage of {@link #getJoinsRoot()} when retrieval of root is requested (to prevent exposing {@link #FIRST_STRATEGY_NAME})
	 * 
	 * @param leftStrategyName join node name to be given
	 * @return null if the node doesn't exist
	 * @see #getJoinsRoot()
	 */
	@Nullable
	public AbstractJoin getJoin(String leftStrategyName) {
		return this.strategyIndex.get(leftStrategyName);
	}
	
	/**
	 * Gives a particular node of the joins graph by its name. Joins graph name are given in return of
	 * {@link #addRelationJoin(String, IEntityMappingStrategy, Column, Column, boolean, BeanRelationFixer)}.
	 * Prefer usage of {@link #getJoinsRoot()} when retrieval of root is requested (to prevent exposing {@link #FIRST_STRATEGY_NAME})
	 * 
	 * @param leftStrategyName join node name to be given
	 * @return null if the node doesn't exist
	 * @see #getJoinsRoot()
	 */
	@Nullable
	public StrategyJoins getStrategyJoins(String leftStrategyName) {
		if (FIRST_STRATEGY_NAME.equals(leftStrategyName)) {
			return getJoinsRoot();
		} else {
			return org.gama.lang.Nullable.nullable(getJoin(leftStrategyName)).map(AbstractJoin::getStrategy).get();
		}
	}
	
	public Query buildSelectQuery() {
		Query query = new Query();
		
		// initialization of the from clause with the very first table
		From from = query.getFromSurrogate().add(root.getTable());
		String tableAlias = columnAliasBuilder.buildAlias(root.getTable(), root.getTableAlias());
		addColumnsToSelect(tableAlias, root.getStrategy().getSelectableColumns(), query);
		
		Queue<AbstractJoin> stack = new ArrayDeque<>(root.getJoins());
		while (!stack.isEmpty()) {
			AbstractJoin<?, ?> join = stack.poll();
			String joinTableAlias = columnAliasBuilder.buildAlias(join.getStrategy().getTable(), join.getStrategy().getTableAlias());
			addColumnsToSelect(joinTableAlias, join.getStrategy().getStrategy().getSelectableColumns(), query);
			Column leftJoinColumn = join.getLeftJoinColumn();
			Column rightJoinColumn = join.getRightJoinColumn();
			from.add(from.new ColumnJoin(leftJoinColumn, rightJoinColumn,
					// NB: if join object is a merge one, sql join will be an inner one (see MergeJoin javadoc for explanation)
					join instanceof RelationJoin && ((RelationJoin<?, ?>) join).isOuter() ? LEFT_OUTER_JOIN : INNER_JOIN));
			
			stack.addAll(join.getStrategy().getJoins());
		}
		
		return query;
	}
	
	/**
	 * Provides tables implied in this join.
	 * 
	 * @return all tables used by this join
	 */
	public Set<Table> giveTables() {
		Set<Table> result = new HashSet<>();
		
		// initialization of the from clause with the very first table
		result.add(root.getTable());
		Queue<AbstractJoin> stack = new ArrayDeque<>(root.getJoins());
		while (!stack.isEmpty()) {
			AbstractJoin<?,?> join = stack.poll();
			result.add(join.getStrategy().getTable());
			stack.addAll(join.getStrategy().getJoins());
		}
		return result;
	}
	
	/**
	 * Adds a join to this select.
	 * Use for one-to-one or one-to-many cases when join is used to describe a related bean. 
	 * 
	 * @param leftStrategyName the name of a (previously) registered join. {@code leftJoinColumn} must be a {@link Column} of its left {@link Table}
	 * @param strategy the strategy of the mapped bean. Used to give {@link Column}s and {@link org.gama.stalactite.persistence.mapping.IRowTransformer}
	 * @param leftJoinColumn the {@link Column} (of previous strategy left table) to be joined with {@code rightJoinColumn}
	 * @param rightJoinColumn the {@link Column} (of the strategy table) to be joined with {@code leftJoinColumn}
	 * @param isOuterJoin says wether or not the join must be open
	 * @param beanRelationFixer a function to fullfill relation between 2 strategies beans
	 * @param <U> type of bean mapped by the given strategy
	 * @param <T1> joined left table
	 * @param <T2> joined right table
	 * @param <ID> type of joined values
	 * @return the name of the created join, to be used as a key for other joins (through this method {@code leftStrategyName} argument)
	 */
	public <U, T1 extends Table<T1>, T2 extends Table<T2>, ID> String addRelationJoin(String leftStrategyName,
																					  IEntityMappingStrategy<U, ID, T2> strategy,
																					  Column<T1, ID> leftJoinColumn,
																					  Column<T2, ID> rightJoinColumn,
																					  boolean isOuterJoin,
																					  BeanRelationFixer beanRelationFixer) {
		return addJoin(leftStrategyName, strategy,
				owningNode -> owningNode.add(strategy, leftJoinColumn, rightJoinColumn, isOuterJoin, beanRelationFixer));
	}
	
	/**
	 * Adds a join to this select.
	 * Use for inheritance cases when joined data are used to complete an existing bean. 
	 *
	 * @param leftStrategyName the name of a (previously) registered join. {@code leftJoinColumn} must be a {@link Column} of its left {@link Table}.
	 * 						Right table data will be merged with this "root".
	 * @param strategy the strategy of the mapped bean. Used to give {@link Column}s and {@link org.gama.stalactite.persistence.mapping.IRowTransformer}
	 * @param leftJoinColumn the {@link Column} (of previous strategy left table) to be joined with {@code rightJoinColumn}
	 * @param rightJoinColumn the {@link Column} (of the strategy table) to be joined with {@code leftJoinColumn}
	 * @param <U> type of bean mapped by the given strategy
	 * @param <T1> joined left table
	 * @param <T2> joined right table
	 * @param <ID> type of joined values
	 * @return the name of the created join, to be used as a key for other joins (through this method {@code leftStrategyName} argument)
	 */
	public <U, T1 extends Table<T1>, T2 extends Table<T2>, ID> String addMergeJoin(String leftStrategyName,
																				   IEntityMappingStrategy<U, ID, T2> strategy,
																				   Column<T1, ID> leftJoinColumn,
																				   Column<T2, ID> rightJoinColumn) {
		return addJoin(leftStrategyName, strategy,
				owningNode -> owningNode.add(strategy, leftJoinColumn, rightJoinColumn));
	}
	
	/**
	 * Adds a join to this select.
	 * Not aimed at being public at first glance, made public to duplicate select tree (may be reviewed).
	 *
	 * @param leftStrategyName the name of a (previously) registered join. {@code leftJoinColumn} must be a {@link Column} of its left {@link Table}.
	 * @param strategy the strategy of the mapped bean. Used to give {@link Column}s and
	 * {@link org.gama.stalactite.persistence.mapping.IRowTransformer}
	 * @param joinFactory builder for adhoc join
	 * @param <U> type of bean mapped by the given strategy
	 * @param <T1> joined left table
	 * @param <T2> joined right table
	 * @param <ID> type of joined values
	 */
	public <U, T1 extends Table<T1>, T2 extends Table<T2>, ID> String addJoin(String leftStrategyName,
																			   IEntityMappingStrategy<U, ID, T2> strategy,
																			   Function<StrategyJoins, AbstractJoin> joinFactory) {
		StrategyJoins owningNode = getStrategyJoins(leftStrategyName);
		if (owningNode == null) {
			throw new IllegalArgumentException("No strategy with name " + leftStrategyName + " exists to add a new strategy on");
		}
		AbstractJoin join = joinFactory.apply(owningNode);
		String indexKey = indexNamer.generateName(strategy);
		this.strategyIndex.put(indexKey, join);
		return indexKey;
	}
	
	private <T1 extends Table<T1>> void addColumnsToSelect(String tableAlias, Iterable<Column<T1, Object>> selectableColumns, Query query) {
		for (Column selectableColumn : selectableColumns) {
			String alias = columnAliasBuilder.buildAlias(tableAlias, selectableColumn);
			query.select(selectableColumn, alias);
			// we link the column alias to the binder so it will be easy to read the ResultSet
			selectParameterBinders.put(alias, parameterBinderProvider.getBinder(selectableColumn));
			aliases.put(selectableColumn, alias);
		}
	}
	
	/**
	 * Joins of a strategy: owns the left part of the join, and "right parts" are represented by a collection of {@link RelationJoin}, ending up with a tree
	 * of joins representing a relation graph.
	 *
	 * @param <I> the type of the entity mapped by the {@link ClassMappingStrategy}
	 */
	public static class StrategyJoins<E, I> {
		/** The left part of the join */
		private final IEntityMappingStrategy<E, ?, ? extends Table> strategy;
		/** Joins */
		private final List<AbstractJoin> joins = new ArrayList<>();
		
		private String tableAlias;
		
		StrategyJoins(IEntityMappingStrategy<E, ?, ? extends Table> strategy) {
			this(strategy, strategy.getTargetTable().getAbsoluteName());
		}
		
		StrategyJoins(IEntityMappingStrategy<E, ?, ? extends Table> strategy, String absoluteName) {
			this.strategy = strategy;
			this.tableAlias = absoluteName;
		}
		
		public <T extends Table> IEntityMappingStrategy<I, Object, T> getStrategy() {
			return (IEntityMappingStrategy<I, Object, T>) strategy;
		}
		
		public List<AbstractJoin> getJoins() {
			return joins;
		}
		
		public Table getTable() {
			return strategy.getTargetTable();
		}
		
		public String getTableAlias() {
			return tableAlias;
		}
		
		/**
		 * To use to force the table alias of the strategy table in the select statement
		 * @param tableAlias not null, nor empty, sql compliant (none checked)
		 */
		public void setTableAlias(String tableAlias) {
			this.tableAlias = tableAlias;
		}
		
		/**
		 * Creates a join between this strategy and the given one.
		 * Method used for one-to-one and one-to-many (owned by reverse side) relations
		 * 
		 * @param strategy the new strategy on which to join
		 * @param leftJoinColumn the column of the owned strategy table (no check done) on which the join will be made
		 * @param rightJoinColumn the column of the new strategy table (no check done) on which the join will be made
		 * @param isOuterJoin indicates if the join is an outer (left) one or not
		 * @param beanRelationFixer will help to apply the instance of the new strategy on the owned one
		 * @return the created join
		 */
		<U, T1 extends Table<T1>, T2 extends Table<T2>, ID> RelationJoin<I,U> add(IEntityMappingStrategy<U, ID, T2> strategy,
																				  Column<T1, ID> leftJoinColumn,
																				  Column<T2, ID> rightJoinColumn,
																				  boolean isOuterJoin,
																				  BeanRelationFixer beanRelationFixer) {
			RelationJoin<I,U> join = new RelationJoin<>(strategy, leftJoinColumn, rightJoinColumn, isOuterJoin, beanRelationFixer);
			this.joins.add(join);
			return join;
		}
		
		/**
		 * Creates a join between this strategy and the given one.
		 * Method used for inheritance cases to complete current strategy with given one
		 *
		 * @param strategy the new strategy on which to join
		 * @param leftJoinColumn the column of the owned strategy table (no check done) on which the join will be made
		 * @param rightJoinColumn the column of the new strategy table (no check done) on which the join will be made
		 * @return the created join
		 */
		<U, T1 extends Table<T1>, T2 extends Table<T2>, ID> MergeJoin add(IEntityMappingStrategy<U, ID, T2> strategy,
																		  Column<T1, ID> leftJoinColumn,
																		  Column<T2, ID> rightJoinColumn) {
			MergeJoin<I,U> join = new MergeJoin<>(strategy, leftJoinColumn, rightJoinColumn);
			this.joins.add(join);
			return join;
		}
		
		/**
		 * Copies this instance into given target at given join node name.
		 * Used to plug this graph as a subgraph of a join node of the given target.
		 * 
		 * @param target the graph that must contain this subgraph
		 * @param targetJoinsNodeName join node target
		 */
		public void copyTo(JoinedStrategiesSelect target, String targetJoinsNodeName) {
			target.getStrategyJoins(targetJoinsNodeName).joins.addAll(this.joins);
		}
		
		/**
		 * Specilization of an {@link AbstractJoin} for relation between beans such as one-to-one or one-to-many
		 */
		public static class RelationJoin<I, O> extends AbstractJoin<I, O> {
			/** Indicates if the join must be an inner or (left) outer join */
			private final boolean outer;
			/** Relation fixer for instances of this strategy on owning strategy entities */
			private final BeanRelationFixer beanRelationFixer;
			private boolean merge;
			
			private RelationJoin(IEntityMappingStrategy<O, ?, ? extends Table> strategy, Column leftJoinColumn, Column rightJoinColumn, boolean outer, BeanRelationFixer beanRelationFixer) {
				super(strategy, leftJoinColumn, rightJoinColumn);
				this.outer = outer;
				this.beanRelationFixer = beanRelationFixer;
			}
			
			public boolean isOuter() {
				return outer;
			}
			
			public BeanRelationFixer getBeanRelationFixer() {
				return beanRelationFixer;
			}
			
			public void setMerge(boolean merge) {
				this.merge = merge;
			}
			
			public boolean shouldMerge() {
				return merge;
			}
		}
		
		/**
		 * Specilization of an {@link AbstractJoin} for cases of inheritance by joined tables. Join will be done with inner kind one because its
		 * seems nonesense to have optional merge information in inheritance cases. 
		 * By itself it indicates that its strategy table content must be merged with its parent {@link StrategyJoins}.
		 */
		public static class MergeJoin<I, O> extends AbstractJoin<I, O> {
			
			private MergeJoin(IEntityMappingStrategy<O, ?, ? extends Table> strategy, Column leftJoinColumn, Column rightJoinColumn) {
				super(strategy, leftJoinColumn, rightJoinColumn);
			}
		}
	}
	
	private static class StrategyIndexNamer {
		
		private int aliasCount = 0;
		
		private String generateName(IEntityMappingStrategy classMappingStrategy) {
			return classMappingStrategy.getTargetTable().getAbsoluteName() + aliasCount++;
		}
	}
	
	private static class ColumnAliasBuilder {
		
		/**
		 * Gives the alias of a table
		 * @param table the {@link Table} for which an alias is requested
		 * @param aliasOverride an optional given alias
		 * @return the given alias in priority or the name of the table
		 */
		public String buildAlias(Table table, String aliasOverride) {
			return (String) Strings.preventEmpty(aliasOverride, table.getName());
		}
		
		/**
		 * Gives the alias of a Column 
		 * @param tableAlias a non-null table alias
		 * @param selectableColumn the {@link Column} for which an alias is requested
		 * @return tableAlias + "_" + column.getName()
		 */
		public String buildAlias(@Nonnull String tableAlias, Column selectableColumn) {
			return tableAlias + "_" + selectableColumn.getName();
		}
	}
}

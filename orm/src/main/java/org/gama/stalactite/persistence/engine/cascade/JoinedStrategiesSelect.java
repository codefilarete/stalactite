package org.gama.stalactite.persistence.engine.cascade;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Set;

import org.gama.lang.Strings;
import org.gama.stalactite.sql.binder.ParameterBinder;
import org.gama.stalactite.sql.binder.ParameterBinderProvider;
import org.gama.stalactite.persistence.engine.BeanRelationFixer;
import org.gama.stalactite.persistence.engine.cascade.JoinedStrategiesSelect.StrategyJoins.Join;
import org.gama.stalactite.persistence.mapping.ClassMappingStrategy;
import org.gama.stalactite.persistence.structure.Column;
import org.gama.stalactite.persistence.structure.Table;
import org.gama.stalactite.query.model.From;
import org.gama.stalactite.query.model.Query;

import static org.gama.stalactite.query.model.From.AbstractJoin.JoinDirection.INNER_JOIN;
import static org.gama.stalactite.query.model.From.AbstractJoin.JoinDirection.LEFT_OUTER_JOIN;

/**
 * Class that eases the creation of a SQL selection with multiple joined {@link ClassMappingStrategy}.
 * The representation of a link between strategies is done through {@link StrategyJoins}.
 * 
 * Joins have a name (very first one is {@value #FIRST_STRATEGY_NAME}, see {@link #FIRST_STRATEGY_NAME}) so one can reference it in further
 * joins for joining a table multiple times.
 *
 * @author Guillaume Mary
 * @see #buildSelectQuery()
 */
public class JoinedStrategiesSelect<C, I, T extends Table> {
	
	/** Key of the very first {@link StrategyJoins} added to the join structure (the one generated by constructor), see {@link #getJoinsRoot()} */
	public static final String FIRST_STRATEGY_NAME = "ROOT";
	
	/** Mappig between column name in select and their {@link ParameterBinder} for reading */
	private final Map<String, ParameterBinder> selectParameterBinders = new HashMap<>();
	/** Aliases of columns. Values are keys of {@link #selectParameterBinders} */
	private final Map<Column, String> aliases = new HashMap<>();
	/** Will give the {@link ParameterBinder} for the reading of the final select clause */
	private final ParameterBinderProvider<Column> parameterBinderProvider;
	/** The very first {@link ClassMappingStrategy} on which other strategies will be joined */
	private final StrategyJoins<C, I> root;
	/**
	 * A mapping between a name and join to help finding them when we want to join them with a new one
	 * @see #add(String, ClassMappingStrategy, Column, Column, boolean, BeanRelationFixer) 
	 */
	private final Map<String, StrategyJoins> strategyIndex = new HashMap<>();
	/** The objet that will help to give names of strategies into the index (no impact on the generated SQL) */
	private final StrategyIndexNamer indexNamer = new StrategyIndexNamer();
	
	private ColumnAliasBuilder columnAliasBuilder = new ColumnAliasBuilder();
	
	/**
	 * Main constructor which gives the very first strategy name as {@value #FIRST_STRATEGY_NAME} (see {@link #FIRST_STRATEGY_NAME})
	 *
	 * @param classMappingStrategy the root strategy, added strategy will be joined wih it
	 * @param parameterBinderProvider the objet that will give {@link ParameterBinder} to read the selected columns
	 */
	JoinedStrategiesSelect(ClassMappingStrategy<C, I, T> classMappingStrategy, ParameterBinderProvider<Column> parameterBinderProvider) {
		this(classMappingStrategy, parameterBinderProvider, FIRST_STRATEGY_NAME);
	}
	
	/**
	 * Constructor that let one gives the very first strategy name.
	 *
	 * @param classMappingStrategy the root strategy, added strategy will be joined wih it
	 * @param parameterBinderProvider the objet that will give {@link ParameterBinder} to read the selected columns
	 * @param strategyName the very first strategy name
	 */
	JoinedStrategiesSelect(ClassMappingStrategy<C, I, T> classMappingStrategy, ParameterBinderProvider<Column> parameterBinderProvider, String strategyName) {
		this.parameterBinderProvider = parameterBinderProvider;
		this.root = new StrategyJoins<>(classMappingStrategy);
		this.strategyIndex.put(strategyName, this.root);
	}
	
	public Map<String, ParameterBinder> getSelectParameterBinders() {
		return selectParameterBinders;
	}
	
	/**
	 * @return the generated aliases by {@link Column} during the {@link #addColumnsToSelect(String, Iterable, Query)} phase
	 */
	public Map<Column, String> getAliases() {
		return aliases;
	}
	
	/**
	 * Give the root of all joins needed by the strategy to build its entity graph at load time and persist it.  
	 * @return a {@link StrategyJoins} which is the root of the graph, which {@link ClassMappingStrategy} is the one given at construction time of this instance
	 */
	public StrategyJoins<C, I> getJoinsRoot() {
		return root;
	}
	
	/**
	 * Gives a particular node of the joins graph by its name. Joins graph name are given in return of
	 * {@link #add(String, ClassMappingStrategy, Column, Column, boolean, BeanRelationFixer)}.
	 * Prefer usage of {@link #getJoinsRoot()} when retrieval of root is requested (to prevent exposing {@link #FIRST_STRATEGY_NAME})
	 * 
	 * @param leftStrategyName join node name to be given
	 * @return null if the node doesn't exist
	 * @see #getJoinsRoot()
	 */
	@Nullable
	public StrategyJoins getStrategyJoins(String leftStrategyName) {
		return this.strategyIndex.get(leftStrategyName);
	}
	
	public Query buildSelectQuery() {
		Query query = new Query();
		
		// initialization of the from clause with the very first table
		From from = query.getFromSurrogate().add(root.getTable());
		String tableAlias = columnAliasBuilder.buildAlias(root.getTable(), root.getTableAlias());
		addColumnsToSelect(tableAlias, root.getStrategy().getSelectableColumns(), query);
		
		Queue<Join> stack = new ArrayDeque<>(root.getJoins());
		while (!stack.isEmpty()) {
			Join<?, ?> join = stack.poll();
			String joinTableAlias = columnAliasBuilder.buildAlias(join.getStrategy().getTable(), join.getStrategy().getTableAlias());
			addColumnsToSelect(joinTableAlias, join.getStrategy().getStrategy().getSelectableColumns(), query);
			Column leftJoinColumn = join.getLeftJoinColumn();
			Column rightJoinColumn = join.getRightJoinColumn();
			from.add(from.new ColumnJoin(leftJoinColumn, rightJoinColumn, join.isOuter() ? LEFT_OUTER_JOIN : INNER_JOIN));
			
			stack.addAll(join.getStrategy().getJoins());
		}
		
		return query;
	}
	
	/**
	 * Provides tables implied in this join.
	 * 
	 * @return all tables used by this join
	 */
	public Set<Table> giveTables() {
		Set<Table> result = new HashSet<>();
		
		// initialization of the from clause with the very first table
		result.add(root.getTable());
		Queue<Join> stack = new ArrayDeque<>(root.getJoins());
		while (!stack.isEmpty()) {
			Join<?, ?> join = stack.poll();
			result.add(join.getStrategy().getTable());
			stack.addAll(join.getStrategy().getJoins());
		}
		return result;
	}
	
	/**
	 * Adds a join to this select.
	 * 
	 * @param leftStrategyName the name of a (previously) registered join. {@code leftJoinColumn} must be a {@link Column} of its left {@link Table}
	 * @param strategy the strategy of the mapped bean. Used to give {@link Column}s and {@link org.gama.stalactite.persistence.mapping.IRowTransformer}
	 * @param leftJoinColumn the {@link Column} (of previous strategy left table) to be joined with {@code rightJoinColumn}
	 * @param rightJoinColumn the {@link Column} (of the strategy table) to be joined with {@code leftJoinColumn}
	 * @param isOuterJoin says wether or not the join must be open
	 * @param beanRelationFixer a function to fullfill relation between 2 strategies beans
	 * @param <U> type of bean mapped by the given strategy
	 * @param <T1> joined left table
	 * @param <T2> joined right table
	 * @param <ID> type of joined values
	 * @return the name of the created join, to be used as a key for other joins (through this method {@code leftStrategyName} argument)
	 */
	public <U, T1 extends Table<T1>, T2 extends Table<T2>, ID> String add(String leftStrategyName, ClassMappingStrategy<U, ID, T2> strategy,
																		  Column<T1, ID> leftJoinColumn, Column<T2, ID> rightJoinColumn,
																		  boolean isOuterJoin, BeanRelationFixer beanRelationFixer) {
		StrategyJoins hangingJoins = getStrategyJoins(leftStrategyName);
		if (hangingJoins == null) {
			throw new IllegalArgumentException("No strategy with name " + leftStrategyName + " exists to add a new strategy on");
		}
		return add(hangingJoins, strategy, leftJoinColumn, rightJoinColumn, isOuterJoin, beanRelationFixer);
	}
	
	private <U, T1 extends Table<T1>, T2 extends Table<T2>, ID> String add(StrategyJoins owner, ClassMappingStrategy<U, ID, T2> strategy,
						   Column<T1, ID> leftJoinColumn, Column<T2, ID> rightJoinColumn, boolean isOuterJoin,
						   BeanRelationFixer beanRelationFixer) {
		Join join = owner.add(strategy, leftJoinColumn, rightJoinColumn, isOuterJoin, beanRelationFixer);
		String indexKey = indexNamer.generateName(strategy);
		strategyIndex.put(indexKey, join.getStrategy());
		return indexKey;
	}
	
	private <T1 extends Table<T1>> void addColumnsToSelect(String tableAlias, Iterable<Column<T1, Object>> selectableColumns, Query query) {
		for (Column selectableColumn : selectableColumns) {
			String alias = columnAliasBuilder.buildAlias(tableAlias, selectableColumn);
			query.select(selectableColumn, alias);
			// we link the column alias to the binder so it will be easy to read the ResultSet
			selectParameterBinders.put(alias, parameterBinderProvider.getBinder(selectableColumn));
			aliases.put(selectableColumn, alias);
		}
	}
	
	/**
	 * Joins of a strategy: owns the left part of the join, and "right parts" are represented by a collection of {@link Join}, ending up with a tree
	 * of joins representing a relation graph.
	 *
	 * @param <I> the type of the entity mapped by the {@link ClassMappingStrategy}
	 */
	public static class StrategyJoins<E, I> {
		/** The left part of the join */
		private final ClassMappingStrategy<E, ?, ? extends Table> strategy;
		/** Joins */
		private final List<Join> joins = new ArrayList<>();
		
		private String tableAlias;
		
		StrategyJoins(ClassMappingStrategy<E, ?, ? extends Table> strategy) {
			this(strategy, strategy.getTargetTable().getAbsoluteName());
		}
		
		StrategyJoins(ClassMappingStrategy<E, ?, ? extends Table> strategy, String absoluteName) {
			this.strategy = strategy;
			this.tableAlias = absoluteName;
		}
		
		public <T extends Table<T>> ClassMappingStrategy<I, Object, T> getStrategy() {
			return (ClassMappingStrategy<I, Object, T>) strategy;
		}
		
		public List<Join> getJoins() {
			return joins;
		}
		
		public Table getTable() {
			return strategy.getTargetTable();
		}
		
		public String getTableAlias() {
			return tableAlias;
		}
		
		/**
		 * To use to force the table alias of the strategy table in the select statement
		 * @param tableAlias not null, nor empty, sql compliant (none checked)
		 */
		public void setTableAlias(String tableAlias) {
			this.tableAlias = tableAlias;
		}
		
		/**
		 * Method dedicated to OneToOne relation
		 * @param strategy the new strategy on which to join
		 * @param leftJoinColumn the column of the owned strategy table (no check done) on which the join will be made
		 * @param rightJoinColumn the column of the new strategy table (no check done) on which the join will be made
		 * @param isOuterJoin indicates if the join is an outer (left) one or not
		 * @param beanRelationFixer will help to apply the instance of the new strategy on the owned one
		 * @return the created join
		 */
		<U> Join<I, U> add(ClassMappingStrategy strategy, Column leftJoinColumn, Column rightJoinColumn, boolean isOuterJoin, BeanRelationFixer beanRelationFixer) {
			Join<I, U> join = new Join<>(strategy, leftJoinColumn, rightJoinColumn, isOuterJoin, beanRelationFixer);
			this.joins.add(join);
			return join;
		}
		
		/**
		 * Copies this instance into given target at given join node name.
		 * Used to plug this graph as a subgraph of a join node of the given target.
		 * 
		 * @param target the graph that must contain this subgraph
		 * @param targetJoinsNodeName join node target
		 */
		public void copyTo(JoinedStrategiesSelect target, String targetJoinsNodeName) {
			target.getStrategyJoins(targetJoinsNodeName).joins.addAll(this.joins);
		}
		
		/** The "right part" of a join between between 2 {@link ClassMappingStrategy} */
		public static class Join<I, O> {
			/** The right part of the join */
			private final StrategyJoins<O, I> strategy;
			/** Join column with previous strategy table */
			private final Column leftJoinColumn;
			/** Join column with next strategy table */
			private final Column rightJoinColumn;
			/** Indicates if the join must be an inner or (left) outer join */
			private final boolean outer;
			/** Relation fixer for instances of this strategy on owning strategy entities */
			private final BeanRelationFixer beanRelationFixer;
			
			private Join(ClassMappingStrategy<O, ?, ? extends Table> strategy, Column leftJoinColumn, Column rightJoinColumn, boolean outer, BeanRelationFixer beanRelationFixer) {
				this.strategy = new StrategyJoins<>(strategy);
				this.leftJoinColumn = leftJoinColumn;
				this.rightJoinColumn = rightJoinColumn;
				this.outer = outer;
				this.beanRelationFixer = beanRelationFixer;
			}
			
			StrategyJoins<O, I> getStrategy() {
				return strategy;
			}
			
			private Column getLeftJoinColumn() {
				return leftJoinColumn;
			}
			
			private Column getRightJoinColumn() {
				return rightJoinColumn;
			}
			
			public boolean isOuter() {
				return outer;
			}
			
			public BeanRelationFixer getBeanRelationFixer() {
				return beanRelationFixer;
			}
		}
	}
	
	private static class StrategyIndexNamer {
		
		private int aliasCount = 0;
		
		private String generateName(ClassMappingStrategy classMappingStrategy) {
			return classMappingStrategy.getTargetTable().getAbsoluteName() + aliasCount++;
		}
	}
	
	private static class ColumnAliasBuilder {
		
		/**
		 * Gives the alias of a table
		 * @param table the {@link Table} for which an alias is requested
		 * @param aliasOverride an optional given alias
		 * @return the given alias in priority or the name of the table
		 */
		public String buildAlias(Table table, String aliasOverride) {
			return (String) Strings.preventEmpty(aliasOverride, table.getName());
		}
		
		/**
		 * Gives the alias of a Column 
		 * @param tableAlias a non-null table alias
		 * @param selectableColumn the {@link Column} for which an alias is requested
		 * @return tableAlias + "_" + column.getName()
		 */
		public String buildAlias(@Nonnull String tableAlias, Column selectableColumn) {
			return tableAlias + "_" + selectableColumn.getName();
		}
	}
}

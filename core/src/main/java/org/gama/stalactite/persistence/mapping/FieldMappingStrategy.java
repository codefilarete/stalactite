package org.gama.stalactite.persistence.mapping;

import org.gama.lang.Reflections;
import org.gama.lang.bean.Objects;
import org.gama.lang.collection.Arrays;
import org.gama.lang.collection.Iterables;
import org.gama.lang.collection.Iterables.ForEach;
import org.gama.lang.exception.Exceptions;
import org.gama.reflection.PropertyAccessor;
import org.gama.stalactite.persistence.sql.dml.PreparedUpdate.UpwhereColumn;
import org.gama.sql.result.Row;
import org.gama.stalactite.persistence.structure.Table;
import org.gama.stalactite.persistence.structure.Table.Column;

import javax.annotation.Nonnull;
import java.io.Serializable;
import java.lang.reflect.Field;
import java.util.*;
import java.util.Map.Entry;

/**
 * @author Guillaume Mary
 */
public class FieldMappingStrategy<T> implements IMappingStrategy<T> {
	
	private final Class<T> classToPersist;
	
	private final Map<PropertyAccessor, Column> fieldToColumn;
	
	private PropertyAccessor<T, Serializable> identifierAccessor;
	
	private final Table targetTable;
	
	private final Set<Column> columns;
	
	private final ToBeanRowTransformer<T> rowTransformer;
	
	private final Iterable<Column> keys;
	
	private final boolean singleColumnKey;
	
	private final Iterable<Column> versionedKeys;
	
	/**
	 * Build a FieldMappingStrategy from a mapping between Field and Column.
	 * Fields are expected to be from same class.
	 * Columns are expected to be from same table.
	 * No control is done about that, caller must be aware of it.
	 * First entry of <tt>fieldToColumn</tt> is used to pick up persisted class and target table.
	 *
	 * @param targetTable
	 * @param fieldToColumn a mapping between Field and Column, expected to be coherent (fields of same class, column of same table)
	 * @param identifierField the field that store entity identifier   
	 */
	public FieldMappingStrategy(Table targetTable, @Nonnull Map<Field, Column> fieldToColumn, Field identifierField) {
		this.targetTable = targetTable;
		this.fieldToColumn = new HashMap<>(fieldToColumn.size());
		if (identifierField == null) {
			throw new UnsupportedOperationException("No identifier field for " + targetTable.getName());
		}
		Map<String, PropertyAccessor> columnToField = new HashMap<>();
		for (Entry<Field, Column> fieldColumnEntry : fieldToColumn.entrySet()) {
			Column column = fieldColumnEntry.getValue();
			PropertyAccessor accessorByField = PropertyAccessor.forProperty(fieldColumnEntry.getKey());
			// autoincrement columns mustn't be written (inserted or updated)
			// NB: as it should be the primary key, the primary key is no more in fieldToColumn but it doesn't matter by the way it's used in getInsertValues or getUpdateValues 
			if (!column.isAutoGenerated()) {
				this.fieldToColumn.put(accessorByField, column);
			}
			columnToField.put(column.getName(), accessorByField);
			if (fieldColumnEntry.getKey().equals(identifierField)) {
				// identifierAccessor must be the same instance as those stored in fieldToColumn for Map.remove method used in foreach()
				this.identifierAccessor = accessorByField;
				if (!column.isPrimaryKey()) {
					throw new UnsupportedOperationException("Field " + identifierField.getDeclaringClass().getName()+"."+identifierField.getName()
							+ " is declared as identifier but mapped column " + column.toString() + " is not the primary key of table");
				}
			}
		}
		this.classToPersist = (Class<T>) identifierField.getDeclaringClass();
		this.rowTransformer = new ToBeanRowTransformer<>(Reflections.getDefaultConstructor(classToPersist), columnToField);
		this.columns = new LinkedHashSet<>(fieldToColumn.values());
		// TODO: distinguish key from version, implement id with multiple column/field
		this.keys = Collections.unmodifiableSet(Arrays.asSet(this.targetTable.getPrimaryKey()));
		this.singleColumnKey = true;
		this.versionedKeys = Collections.unmodifiableSet(Arrays.asSet(this.targetTable.getPrimaryKey()));
	}
	
	@Override
	public Table getTargetTable() {
		return targetTable;
	}
	
	/**
	 * Gives mapped columns (can be a subset of the target table)
	 * @return
	 */
	public Set<Column> getColumns() {
		return columns;
	}
	
	public ToBeanRowTransformer<T> getRowTransformer() {
		return rowTransformer;
	}
	
	@Override
	public Map<Column, Object> getInsertValues(@Nonnull final T t) {
		return foreachField(new FieldVisitor<Column>() {
			@Override
			protected void visitField(Entry<PropertyAccessor, Column> fieldColumnEntry) throws IllegalAccessException {
				toReturn.put(fieldColumnEntry.getValue(), fieldColumnEntry.getKey().get(t));
			}
		}, true);	// primary key must be inserted (not if DB gives it but it's not implemented yet)
	}
	
	@Override
	public Map<UpwhereColumn, Object> getUpdateValues(@Nonnull final T modified, final T unmodified, final boolean allColumns) {
		final Map<Column, Object> unmodifiedColumns = new LinkedHashMap<>();
		// getting differences
		Map<UpwhereColumn, Object> toReturn = foreachField(new FieldVisitor<UpwhereColumn>() {
			@Override
			protected void visitField(Entry<PropertyAccessor, Column> fieldColumnEntry) throws IllegalAccessException {
				PropertyAccessor<T, Object> accessor = fieldColumnEntry.getKey();
				Object modifiedValue = accessor.get(modified);
				Object unmodifiedValue = unmodified == null ? null : accessor.get(unmodified);
				Column fieldColumn = fieldColumnEntry.getValue();
				if (!Objects.equalsWithNull(modifiedValue, unmodifiedValue)) {
					toReturn.put(new UpwhereColumn(fieldColumn, true), modifiedValue);
				} else {
					unmodifiedColumns.put(fieldColumn, modifiedValue);
				}
			}
		}, false);	// primary key mustn't be updated
		
		if (!toReturn.isEmpty()) {
			// adding complementary columns if necessary
			if (allColumns) {
				for (Entry<Column, Object> unmodifiedField : unmodifiedColumns.entrySet()) {
					toReturn.put(new UpwhereColumn(unmodifiedField.getKey(), true), unmodifiedField.getValue());
				}
			}
			for (Entry<Column, Object> entry : getVersionedKeyValues(modified).entrySet()) {
				toReturn.put(new UpwhereColumn(entry.getKey(), false), entry.getValue());
			}
		}
		return toReturn;
	}
	
	@Override
	public Map<Column, Object> getDeleteValues(@Nonnull T t) {
		Map<Column, Object> toReturn = new HashMap<>();
		putVersionedKeyValues(t, toReturn);
		return toReturn;
	}
	
	@Override
	public Map<Column, Object> getSelectValues(@Nonnull Serializable id) {
		Map<Column, Object> toReturn = new HashMap<>();
		toReturn.put(this.targetTable.getPrimaryKey(), id);
		return toReturn;
	}
	
	@Override
	public Map<Column, Object> getVersionedKeyValues(@Nonnull T t) {
		Map<Column, Object> toReturn = new HashMap<>();
		putVersionedKeyValues(t, toReturn);
		return toReturn;
	}
	
	public Iterable<Column> getVersionedKeys() {
		return versionedKeys;
	}
	
	public Iterable<Column> getKeys() {
		return keys;
	}
	
	public boolean isSingleColumnKey() {
		return singleColumnKey;
	}
	
	public Column getSingleColumnKey() {
		if (!singleColumnKey) {
			throw new UnsupportedOperationException("Can't give only when key when several exist");
		}
		return Iterables.first(keys);
	}
	
	@Override
	public Serializable getId(T t) {
		return identifierAccessor.get(t);
	}
	
	@Override
	public void setId(T t, Serializable identifier) {
		identifierAccessor.set(t, identifier);
	}
	
	private <K> Map<K, Object> foreachField(final FieldVisitor<K> visitor, boolean withPK) {
		Map<PropertyAccessor, Column> fieldsTobeVisited = new HashMap<>(this.fieldToColumn);
		if (!withPK) {
			fieldsTobeVisited.remove(this.identifierAccessor);
		}
		Iterables.visit(fieldsTobeVisited.entrySet(), visitor);
		return visitor.toReturn;
	}
	
	protected void putVersionedKeyValues(T t, Map<Column, Object> toReturn) {
		toReturn.put(this.targetTable.getPrimaryKey(), getId(t));
	}
	
	@Override
	public T transform(Row row) {
		return this.rowTransformer.transform(row);
	}
	
	private static abstract class FieldVisitor<K> extends ForEach<Entry<PropertyAccessor, Column>, Map<K, Object>> {
		
		protected Map<K, Object> toReturn = new HashMap<>();
		
		@Override
		public final Map<K, Object> visit(Entry<PropertyAccessor, Column> fieldColumnEntry) {
			try {
				visitField(fieldColumnEntry);
			} catch (IllegalAccessException e) {
				Exceptions.throwAsRuntimeException(e);
			}
			return null;
		}
		
		protected abstract void visitField(Entry<PropertyAccessor, Column> fieldColumnEntry) throws IllegalAccessException;
	}
}

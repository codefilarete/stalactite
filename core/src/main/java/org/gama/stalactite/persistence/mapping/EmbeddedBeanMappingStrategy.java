package org.gama.stalactite.persistence.mapping;

import javax.annotation.Nonnull;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.function.Consumer;
import java.util.function.Function;

import org.gama.lang.Duo;
import org.gama.lang.Reflections;
import org.gama.lang.collection.Iterables;
import org.gama.lang.function.Predicates;
import org.gama.reflection.Accessors;
import org.gama.reflection.IMutator;
import org.gama.reflection.IReversibleAccessor;
import org.gama.stalactite.persistence.structure.Column;
import org.gama.stalactite.persistence.structure.Table;
import org.gama.stalactite.sql.result.Row;

/**
 * Persistence strategy for simple "embedded" bean (no identifier nor relation managed here) : kind of straight mapping betwen some properties
 * of a class and some columns of a table.
 * 
 * @author Guillaume Mary
 */
public class EmbeddedBeanMappingStrategy<C, T extends Table> implements IEmbeddedBeanMappingStrategy<C, T> {
	
	private final Class<C> classToPersist;
	
	private final T targetTable;
	
	private final Map<IReversibleAccessor<C, Object>, Column<T, Object>> propertyToColumn;
	
	private final Set<Column<T, Object>> columns;
	
	private final ToBeanRowTransformer<C> rowTransformer;
	
	private DefaultValueDeterminer defaultValueDeterminer = new DefaultValueDeterminer() {};
	
	/**
	 * Columns (and their value provider) which are not officially mapped by a bean property.
	 * Those are for insertion time.
	 */
	private final List<Duo<Column<T, ?>, Function<C, ?>>> silentInsertedColumns = new ArrayList<>();
	
	/**
	 * Columns (and their value provider) which are not officially mapped by a bean property.
	 * Those are for update time.
	 */
	private final List<Duo<Column<T, ?>, Function<C, ?>>> silentUpdatedColumns = new ArrayList<>();
	
	/**
	 * Build a EmbeddedBeanMappingStrategy from a mapping between Field and Column.
	 * Fields are expected to be from same class.
	 * Columns are expected to be from same table.
	 * No control is done about that, caller must be aware of it.
	 * First entry of {@code propertyToColumn} is used to pick up persisted class and target table.
	 *
	 * @param classToPersist the class to be persisted
	 * @param targetTable the persisting table
	 * @param propertyToColumn a mapping between Field and Column, expected to be coherent (fields of same class, column of same table)
	 */
	public EmbeddedBeanMappingStrategy(Class<C> classToPersist, T targetTable, Map<? extends IReversibleAccessor<C, Object>, Column<T, Object>> propertyToColumn) {
		this(classToPersist, targetTable, propertyToColumn, row -> Reflections.newInstance(classToPersist));
	}
	
	public EmbeddedBeanMappingStrategy(Class<C> classToPersist,
									   T targetTable,
									   Map<? extends IReversibleAccessor<C, Object>, Column<T, Object>> propertyToColumn,
									   Function<Function<Column, Object>, C> beanFactory) {
		this.classToPersist = classToPersist;
		this.targetTable = targetTable;
		this.propertyToColumn = new HashMap<>(propertyToColumn);
		this.propertyToColumn.entrySet().removeIf(columnEntry -> {
			// autoincrement and primary key columns mustn't be written (inserted nor updated) by this class
			Column<T, Object> column = columnEntry.getValue();
			return column.isAutoGenerated() || column.isPrimaryKey();
		});
		Map<Column<T, Object>, IMutator> columnToField = Iterables.map(propertyToColumn.entrySet(), Entry::getValue, e -> e.getKey().toMutator());
		this.rowTransformer = new EmbeddedBeanRowTransformer(beanFactory, (Map) columnToField);
		this.columns = new LinkedHashSet<>(propertyToColumn.values());
	}
	
	public Class<C> getClassToPersist() {
		return classToPersist;
	}
	
	public T getTargetTable() {
		return targetTable;
	}
	
	/**
	 * @return an immutable {@link Map} of the configured mapping
	 */
	public Map<IReversibleAccessor<C, Object>, Column<T, Object>> getPropertyToColumn() {
		return Collections.unmodifiableMap(propertyToColumn);
	}
	
	/**
	 * Gives mapped columns (can be a subset of the target table)
	 * @return target mapped columns
	 */
	@Nonnull
	@Override
	public Set<Column<T, Object>> getColumns() {
		return Collections.unmodifiableSet(columns);
	}
	
	public ToBeanRowTransformer<C> getRowTransformer() {
		return rowTransformer;
	}
	
	/**
	 * Changes current {@link DefaultValueDeterminer}
	 * 
	 * @param defaultValueDeterminer a {@link DefaultValueDeterminer}
	 */
	public void setDefaultValueDeterminer(DefaultValueDeterminer defaultValueDeterminer) {
		this.defaultValueDeterminer = defaultValueDeterminer;
	}
	
	@Override
	public <O> void addSilentColumnInserter(Column<T, O> column, Function<C, O> valueProvider) {
		silentInsertedColumns.add(new Duo<>(column, valueProvider));
	}
	
	@Override
	public <O> void addSilentColumnUpdater(Column<T, O> column, Function<C, O> valueProvider) {
		silentUpdatedColumns.add(new Duo<>(column, valueProvider));
	}
	
	@Nonnull
	@Override
	public Map<Column<T, Object>, Object> getInsertValues(C c) {
		Map<Column<T, Object>, Object> result = foreachField(new FieldVisitor<Column<T, Object>>() {
			@Override
			protected void visitField(Entry<IReversibleAccessor<C, Object>, Column<T, Object>> fieldColumnEntry) {
				toReturn.put(fieldColumnEntry.getValue(), fieldColumnEntry.getKey().get(c));
			}
		});
		silentInsertedColumns.forEach(columnFunctionDuo -> result.put((Column<T, Object>) columnFunctionDuo.getLeft(), columnFunctionDuo.getRight().apply(c)));
		return result;
	}
	
	@Nonnull
	@Override
	public Map<UpwhereColumn<T>, Object> getUpdateValues(C modified, C unmodified, boolean allColumns) {
		Map<Column<T, Object>, Object> unmodifiedColumns = new HashMap<>();
		// getting differences
		Map<UpwhereColumn<T>, Object> modifiedFields = foreachField(new FieldVisitor<UpwhereColumn<T>>() {
			@Override
			protected void visitField(Entry<IReversibleAccessor<C, Object>, Column<T, Object>> fieldColumnEntry) {
				IReversibleAccessor<C, Object> accessor = fieldColumnEntry.getKey();
				Object modifiedValue = accessor.get(modified);
				Object unmodifiedValue = unmodified == null ? null : accessor.get(unmodified);
				Column<T, Object> fieldColumn = fieldColumnEntry.getValue();
				if (!Predicates.equalOrNull(modifiedValue, unmodifiedValue)
						// OR is here to take cases where getUpdateValues(..) gets only "modified" parameter (such as for updateById) and
						// some modified properties are null, without this OR such properties won't be updated (set to null)
						// and, overall, if they are all null, modifiedFields is empty then causing a statement without values 
						|| unmodified == null) {
					toReturn.put(new UpwhereColumn<>(fieldColumn, true), modifiedValue);
				} else {
					unmodifiedColumns.put(fieldColumn, modifiedValue);
				}
			}
		});
		
		// adding complementary columns if necessary
		if (!modifiedFields.isEmpty() && allColumns) {
			for (Entry<Column<T, Object>, Object> unmodifiedField : unmodifiedColumns.entrySet()) {
				modifiedFields.put(new UpwhereColumn<>(unmodifiedField.getKey(), true), unmodifiedField.getValue());
			}
		}
		// getting values for silent columns
		silentUpdatedColumns.forEach(columnFunctionDuo -> {
			Object modifiedValue = columnFunctionDuo.getRight().apply(modified);
			modifiedFields.put(new UpwhereColumn<>(columnFunctionDuo.getLeft(), true), modifiedValue);
		});
		return modifiedFields;
	}
	
	private <K> Map<K, Object> foreachField(FieldVisitor<K> visitor) {
		this.propertyToColumn.entrySet().forEach(visitor::visitField);
		return visitor.toReturn;
	}
	
	@Override
	public C transform(Row row) {
		// NB: please note that this transfomer will determine intermediary bean instanciation through isDefaultValue(..)
		return this.rowTransformer.transform(row);
	}
	
	@Override
	public AbstractTransformer<C> copyTransformerWithAliases(ColumnedRow columnedRow) {
		return getRowTransformer().copyWithAliases(columnedRow);
	}
	
	private abstract class FieldVisitor<K> implements Consumer<Entry<IReversibleAccessor<C, Object>, Column<T, Object>>> {
		
		protected final Map<K, Object> toReturn = new HashMap<>();
		
		@Override
		public final void accept(Entry<IReversibleAccessor<C, Object>, Column<T, Object>> fieldColumnEntry) {
			visitField(fieldColumnEntry);
		}

		protected abstract void visitField(Entry<IReversibleAccessor<C, Object>, Column<T, Object>> fieldColumnEntry);
	}
	
	/**
	 * Transformer aimed at detecting if bean instance must be created according to row values (used in the select phase).
	 * For example, if all column values are null, bean will not be created.
	 */
	private class EmbeddedBeanRowTransformer extends ToBeanRowTransformer<C> {
		
		public EmbeddedBeanRowTransformer(Class<C> clazz, Map<Column, IMutator> columnToMember) {
			super(clazz, columnToMember);
		}
		
		public EmbeddedBeanRowTransformer(Function<Function<Column, Object>, C> beanFactory, Map<Column, IMutator> columnToMember) {
			super(beanFactory, columnToMember);
		}
		
		@Override
		protected void applyValueToBean(C targetRowBean, Entry<Column, IMutator> columnFieldEntry, Object propertyValue) {
			boolean defaultValue = EmbeddedBeanMappingStrategy.this.defaultValueDeterminer.isDefaultValue(
					new Duo<>(columnFieldEntry.getKey(), columnFieldEntry.getValue()), propertyValue);
			if (!defaultValue) {
				super.applyValueToBean(targetRowBean, columnFieldEntry, propertyValue);
			}
		}
	}
	
	/**
	 * Small constract that helps to determine if a value is a default one for a bean property.
	 * Aimed at deciding if embedded beans must be instanciated or not according to row values (from {@link java.sql.ResultSet}
	 * during the conversion phase
	 */
	public interface DefaultValueDeterminer {

		/**
		 * Default implementation considers null as a default value for non primitive types, and default primitive type values as such for
		 * primitive types (took in {@link Reflections#PRIMITIVE_DEFAULT_VALUES}).
		 * 
		 * @param mappedProperty column and its mapped property (configured in the {@link EmbeddedBeanMappingStrategy}).
		 * 						 So one can use either the column or the accessor for fine grained default value determination
		 * @param value value coming from a JDBC {@link java.sql.ResultSet}, mapped by the couple {@link Column} + {@link IMutator}.
		 * @return true if value is a default one for column/property
		 */
		default boolean isDefaultValue(Duo<Column, IMutator> mappedProperty, Object value) {
			Class inputType = Accessors.giveInputType(mappedProperty.getRight());
			return (!inputType.isPrimitive() && value == null)
					|| (inputType.isPrimitive() && Reflections.PRIMITIVE_DEFAULT_VALUES.get(inputType) == value);
		}
		
	}
}

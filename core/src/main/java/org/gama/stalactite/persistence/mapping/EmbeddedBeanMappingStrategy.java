package org.gama.stalactite.persistence.mapping;

import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.function.Consumer;

import org.gama.lang.Reflections;
import org.gama.lang.bean.Objects;
import org.gama.reflection.IMutator;
import org.gama.reflection.PropertyAccessor;
import org.gama.sql.result.Row;
import org.gama.stalactite.persistence.sql.dml.PreparedUpdate.UpwhereColumn;
import org.gama.stalactite.persistence.structure.Table.Column;

/**
 * @author Guillaume Mary
 */
public class EmbeddedBeanMappingStrategy<T> implements IEmbeddedBeanMapper<T> {
	
	private final Map<PropertyAccessor, Column> propertyToColumn;
	
	private final Set<Column> columns;
	
	private final ToBeanRowTransformer<T> rowTransformer;
	
	/**
	 * Build a EmbeddedBeanMappingStrategy from a mapping between Field and Column.
	 * Fields are expected to be from same class.
	 * Columns are expected to be from same table.
	 * No control is done about that, caller must be aware of it.
	 * First entry of <tt>propertyToColumn</tt> is used to pick up persisted class and target table.
	 *
	 * @param targetClass the class to persist
	 * @param propertyToColumn a mapping between Field and Column, expected to be coherent (fields of same class, column of same table)
	 */
	public EmbeddedBeanMappingStrategy(Class<T> targetClass, Map<PropertyAccessor, Column> propertyToColumn) {
		this.propertyToColumn = new HashMap<>(propertyToColumn.size());
		Map<Column, IMutator> columnToField = new HashMap<>();
		for (Entry<PropertyAccessor, Column> fieldColumnEntry : propertyToColumn.entrySet()) {
			Column column = fieldColumnEntry.getValue();
			PropertyAccessor accessorByField = fieldColumnEntry.getKey();
			// autoincrement columns mustn't be written (inserted or updated)
			// NB: as it should be the primary key, the primary key is no more in propertyToColumn but it doesn't matter by the way it's used in getInsertValues or getUpdateValues 
			if (!column.isAutoGenerated() && !column.isPrimaryKey()) {
				this.propertyToColumn.put(accessorByField, column);
			}
			columnToField.put(column, accessorByField);
		}
		this.rowTransformer = new ToBeanRowTransformer<>(Reflections.getDefaultConstructor(targetClass), columnToField);
		this.columns = new LinkedHashSet<>(propertyToColumn.values());
	}
	
	public Map<PropertyAccessor, Column> getPropertyToColumn() {
		return propertyToColumn;
	}
	
	/**
	 * Gives mapped columns (can be a subset of the target table)
	 * @return
	 */
	@Override
	public Set<Column> getColumns() {
		return columns;
	}
	
	public ToBeanRowTransformer<T> getRowTransformer() {
		return rowTransformer;
	}
	
	@Override
	public Map<Column, Object> getInsertValues(T t) {
		return foreachField(new FieldVisitor<Column>() {
			@Override
			protected void visitField(Entry<PropertyAccessor, Column> fieldColumnEntry) {
				toReturn.put(fieldColumnEntry.getValue(), fieldColumnEntry.getKey().get(t));
			}
		});
	}
	
	@Override
	public Map<UpwhereColumn, Object> getUpdateValues(T modified, T unmodified, boolean allColumns) {
		Map<Column, Object> unmodifiedColumns = new HashMap<>();
		// getting differences
		Map<UpwhereColumn, Object> toReturn = foreachField(new FieldVisitor<UpwhereColumn>() {
			@Override
			protected void visitField(Entry<PropertyAccessor, Column> fieldColumnEntry) {
				PropertyAccessor<T, Object> accessor = fieldColumnEntry.getKey();
				Object modifiedValue = accessor.get(modified);
				Object unmodifiedValue = unmodified == null ? null : accessor.get(unmodified);
				Column fieldColumn = fieldColumnEntry.getValue();
				if (!Objects.equalsWithNull(modifiedValue, unmodifiedValue)) {
					toReturn.put(new UpwhereColumn(fieldColumn, true), modifiedValue);
				} else {
					unmodifiedColumns.put(fieldColumn, modifiedValue);
				}
			}
		});
		
		// adding complementary columns if necessary
		if (!toReturn.isEmpty() && allColumns) {
			for (Entry<Column, Object> unmodifiedField : unmodifiedColumns.entrySet()) {
				toReturn.put(new UpwhereColumn(unmodifiedField.getKey(), true), unmodifiedField.getValue());
			}
		}
		return toReturn;
	}
	
	private <K> Map<K, Object> foreachField(FieldVisitor<K> visitor) {
		this.propertyToColumn.entrySet().forEach(visitor::visitField);
		return visitor.toReturn;
	}
	
	@Override
	public T transform(Row row) {
		return this.rowTransformer.transform(row);
	}
	
	private static abstract class FieldVisitor<K> implements Consumer<Entry<PropertyAccessor, Column>> {
		
		protected Map<K, Object> toReturn = new HashMap<>();
		
		@Override
		public final void accept(Entry<PropertyAccessor, Column> fieldColumnEntry) {
			visitField(fieldColumnEntry);
		}

		protected abstract void visitField(Entry<PropertyAccessor, Column> fieldColumnEntry);
	}
}

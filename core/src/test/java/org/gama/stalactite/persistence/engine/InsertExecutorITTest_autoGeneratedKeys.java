package org.gama.stalactite.persistence.engine;

import javax.sql.DataSource;
import java.io.Serializable;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;
import java.util.Map;
import java.util.function.BiFunction;

import com.tngtech.java.junit.dataprovider.DataProvider;
import com.tngtech.java.junit.dataprovider.DataProviderRunner;
import com.tngtech.java.junit.dataprovider.UseDataProvider;
import org.gama.lang.Retryer;
import org.gama.lang.StringAppender;
import org.gama.lang.collection.Arrays;
import org.gama.lang.collection.Iterables;
import org.gama.lang.trace.IncrementableInt;
import org.gama.reflection.PropertyAccessor;
import org.gama.sql.dml.GeneratedKeysReader;
import org.gama.sql.dml.WriteOperation;
import org.gama.sql.result.Row;
import org.gama.sql.test.DerbyInMemoryDataSource;
import org.gama.sql.test.HSQLDBInMemoryDataSource;
import org.gama.sql.test.MariaDBEmbeddableDataSource;
import org.gama.stalactite.persistence.engine.DMLExecutorTest.PersistenceConfigurationBuilder.TableAndClass;
import org.gama.stalactite.persistence.mapping.ClassMappingStrategy;
import org.gama.stalactite.persistence.sql.ddl.DDLTableGenerator;
import org.gama.stalactite.persistence.sql.dml.DMLGenerator;
import org.gama.stalactite.persistence.structure.Table;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import static org.junit.Assert.assertEquals;

/**
 * @author Guillaume Mary
 */
@RunWith(DataProviderRunner.class)
public class InsertExecutorITTest_autoGeneratedKeys extends DMLExecutorTest {
	
	protected IncrementableInt generatedKeysGetCallCount;
	
	@Before
	public void initGeneratedKeysGetCallCount() {
		generatedKeysGetCallCount = new IncrementableInt();
	}
	
	@Override
	protected PersistenceConfigurationBuilder newPersistenceConfigurationBuilder() {
		return new PersistenceConfigurationBuilder<Toto, Integer>()
				.withTableAndClass("Toto", Toto.class, new BiFunction<TableAndClass<Toto>, PropertyAccessor<Toto, Integer>, ClassMappingStrategy<Toto, Integer>>() {
							@Override
							public ClassMappingStrategy<Toto, Integer> apply(PersistenceConfigurationBuilder.TableAndClass<Toto> tableAndClass, PropertyAccessor<Toto, Integer> primaryKeyField) {
								tableAndClass.targetTable.getPrimaryKey().setAutoGenerated(true);
								
								return new ClassMappingStrategy<>(tableAndClass.mappedClass, tableAndClass.targetTable, tableAndClass.persistentFieldHarverster.getFieldToColumn(), primaryKeyField,
										new InsertExecutorTest.InsertExecutorTest_withAutoGenerateKeys.PrimaryKeyReaderFromGeneratedKeys(tableAndClass.targetTable.getPrimaryKey().getName()) {
											@Override
											public Serializable get(Map<String, Object> generatedKeys) {
												generatedKeysGetCallCount.increment();
												return super.get(generatedKeys);
											}
										},
										new InsertExecutorITTest_autoGeneratedKeys.GeneratedKeysReaderAsInt(tableAndClass.targetTable.getPrimaryKey().getName()));
							}
							
						})
				.withPrimaryKeyFieldName("a");
	}
	
	@DataProvider
	public static Object[][] dataSources() {
		return new Object[][] {
				{ new HSQLDBInMemoryDataSource(), new DDLTableGenerator(dialect.getJavaTypeToSqlTypeMapping()) {
					
					@Override
					protected String getSqlType(Table.Column column) {
						String sqlType = super.getSqlType(column);
						if (column.isAutoGenerated()) {
							sqlType += " GENERATED ALWAYS AS IDENTITY (START WITH 1, INCREMENT BY 1)";
						}
						return sqlType;
					}
					
					/** Overriden to do nothing because HSQLDB does not support "primary key" and "identity" */
					@Override
					protected void generateCreatePrimaryKey(Table table, StringAppender sqlCreateTable) {
					}
				}},
				{ new MariaDBEmbeddableDataSource(3406), new DDLTableGenerator(dialect.getJavaTypeToSqlTypeMapping()) {
					
					@Override
					protected String getSqlType(Table.Column column) {
						String sqlType = super.getSqlType(column);
						if (column.isAutoGenerated()) {
							sqlType += " auto_increment";
						}
						return sqlType;
					}
				}},
		};
	}
	
	@Test
	@UseDataProvider("dataSources")
	public void testInsert_generated_pk_real_life(final DataSource dataSource, DDLTableGenerator ddlTableGenerator) throws SQLException {
		transactionManager.setDataSource(dataSource);
		
		dialect.getDdlSchemaGenerator().setDdlTableGenerator(ddlTableGenerator);
		
		DDLDeployer ddlDeployer = new DDLDeployer(dialect.getDdlSchemaGenerator(), transactionManager) {
			@Override
			protected Connection getCurrentConnection() throws SQLException {
				return dataSource.getConnection();
			}
		};
		ddlDeployer.getDdlSchemaGenerator().setTables(Arrays.asList(persistenceConfiguration.targetTable));
		ddlDeployer.deployDDL();
		
		DMLGenerator dmlGenerator = new DMLGenerator(dialect.getColumnBinderRegistry(), new DMLGenerator.CaseSensitiveSorter());
		InsertExecutor<Toto, Integer> testInstance = new InsertExecutor<>(persistenceConfiguration.classMappingStrategy, transactionManager, dmlGenerator, Retryer.NO_RETRY, 3, 3);
		List<Toto> totoList = Arrays.asList(new Toto(17, 23), new Toto(29, 31), new Toto(37, 41), new Toto(43, 53));
		testInstance.insert(totoList);
		
		assertEquals(4, generatedKeysGetCallCount.getValue());	// if it fails with 0 it means that statement.getGeneratedKeys() returned an empty ResultSet
		// Verfy that database generated keys were set to Java instances
		int i = 1;
		for (Toto toto : totoList) {
			assertEquals(i++, (int) toto.a);
		}
	}
	
	public static class GeneratedKeysReaderAsInt extends GeneratedKeysReader {
		public GeneratedKeysReaderAsInt(String keyName) {
			super(keyName);
		}
		
		/** Overriden to use ResultSet.getInt instead of getLong because Toto.a is of type int (avoid exception (wrong type) during field set) */
		@Override
		protected Object readKey(ResultSet rs) throws SQLException {
			return rs.getInt(1);
		}
	}
	
	public static class InsertExecutorITTest_autoGeneratedKeys_Derby extends InsertExecutorITTest_autoGeneratedKeys {
		
		@DataProvider
		public static Object[][] dataSources() {
			return new Object[][] {
					{ new DerbyInMemoryDataSource(), new DDLTableGenerator(dialect.getJavaTypeToSqlTypeMapping()) {
						
						@Override
						protected String getSqlType(Table.Column column) {
							String sqlType = super.getSqlType(column);
							if (column.isAutoGenerated()) {
								sqlType += " GENERATED ALWAYS AS IDENTITY (START WITH 1, INCREMENT BY 1)";
							}
							return sqlType;
						}
					} },
			};
		}
		
		@Override
		protected PersistenceConfigurationBuilder newPersistenceConfigurationBuilder() {
			return new PersistenceConfigurationBuilder<Toto, Integer>()
					.withTableAndClass("Toto", Toto.class, new BiFunction<PersistenceConfigurationBuilder.TableAndClass<Toto>, PropertyAccessor<Toto, Integer>, ClassMappingStrategy<Toto, Integer>>() {
						@Override
						public ClassMappingStrategy<Toto, Integer> apply(final PersistenceConfigurationBuilder.TableAndClass<Toto> tableAndClass, PropertyAccessor<Toto, Integer> primaryKeyField) {
							tableAndClass.targetTable.getPrimaryKey().setAutoGenerated(true);
							
							return new ClassMappingStrategy<>(tableAndClass.mappedClass, tableAndClass.targetTable, tableAndClass.persistentFieldHarverster.getFieldToColumn(), primaryKeyField,
									new InsertExecutorTest.InsertExecutorTest_withAutoGenerateKeys.PrimaryKeyReaderFromGeneratedKeys(tableAndClass.targetTable.getPrimaryKey().getName()) {
										@Override
										public Serializable get(Map<String, Object> generatedKeys) {
											generatedKeysGetCallCount.increment();
											return super.get(generatedKeys);
										}
									},
									new GeneratedKeysReaderAsInt(tableAndClass.targetTable.getPrimaryKey().getName()) {
										/** Overriden to simulate generated keys for Derby because it only returns the highest generated key */
										@Override
										public List<Row> read(WriteOperation writeOperation) throws SQLException {
											List<Row> rows = super.read(writeOperation);
											// Derby only returns one row: the highest generated key
											Row first = Iterables.first(rows);
											int returnedKey = (int) first.get(getKeyName());
											// we append the missing values in incrementing order, assuming that's a one by one increment
											for (int i = 0; i < writeOperation.getUpdatedRowCount(); i++) {
												Row row = new Row();
												row.put(getKeyName(),returnedKey-i);
												rows.add(0, row);
											}
											return rows;
										}
									});
						}
						
					})
					.withPrimaryKeyFieldName("a");
		}
	}
}
package org.gama.stalactite.persistence.engine;

import java.io.Serializable;
import java.lang.reflect.Field;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.List;
import java.util.Map;

import org.gama.lang.Retryer;
import org.gama.lang.bean.Objects;
import org.gama.lang.collection.Arrays;
import org.gama.stalactite.persistence.id.AfterInsertIdentifierGenerator;
import org.gama.stalactite.persistence.mapping.ClassMappingStrategy;
import org.gama.stalactite.persistence.sql.dml.DMLGenerator;
import org.gama.stalactite.test.PairSetList;
import org.junit.Test;

import static org.junit.Assert.assertEquals;
import static org.mockito.Matchers.anyString;
import static org.mockito.Matchers.eq;
import static org.mockito.Mockito.*;

/**
 * @author Guillaume Mary
 */
public class InsertExecutorTest extends DMLExecutorTest {
	
	private InsertExecutor<Toto> testInstance;
	
	public void setUpTest() throws SQLException {
		super.setUpTest();
		DMLGenerator dmlGenerator = new DMLGenerator(dialect.getColumnBinderRegistry(), new DMLGenerator.CaseSensitiveSorter());
		testInstance = new InsertExecutor<>(persistenceConfiguration.classMappingStrategy, transactionManager, dmlGenerator, Retryer.NO_RETRY, 3, 3);
	}
	
	@Test
	public void testInsert_simple() throws Exception {
		testInstance.insert(Arrays.asList(new Toto(17, 23), new Toto(29, 31), new Toto(37, 41), new Toto(43, 53)));
		
		verify(preparedStatement, times(4)).addBatch();
		verify(preparedStatement, times(2)).executeBatch();
		verify(preparedStatement, times(12)).setInt(indexCaptor.capture(), valueCaptor.capture());
		assertEquals("insert into Toto(a, b, c) values (?, ?, ?)", statementArgCaptor.getValue());
		PairSetList<Integer, Integer> expectedPairs = new PairSetList<Integer, Integer>()
				.of(1, 1).add(2, 17).add(3, 23)
				.of(1, 2).add(2, 29).add(3, 31)
				.of(1, 3).add(2, 37).add(3, 41)
				.of(1, 4).add(2, 43).add(3, 53);
		assertCapturedPairsEqual(expectedPairs);
	}
	
	public static class InsertExecutorTest_withAutoGenerateKeys extends DMLExecutorTest {
		
		// changing mapping strategy to add AfterInsertIdentifierGenerator and GeneratedKeysReader
		@Override
		protected PersistenceConfigurationBuilder newPersistenceConfigurationBuilder() {
			return new PersistenceConfigurationBuilder<Toto>()
					.withTableAndClass("Toto", Toto.class, new Objects.BiFunction<PersistenceConfigurationBuilder.TableAndClass<Toto>, Field, ClassMappingStrategy<Toto>>() {
								@Override
								public ClassMappingStrategy<Toto> apply(final PersistenceConfigurationBuilder.TableAndClass<Toto> tableAndClass, Field primaryKeyField) {
									tableAndClass.targetTable.getPrimaryKey().setAutoGenerated(true);
									
									return new ClassMappingStrategy<>(tableAndClass.mappedClass, tableAndClass.targetTable, tableAndClass.persistentFieldHarverster.getFieldToColumn(), primaryKeyField,
											new PrimaryKeyReaderFromGeneratedKeys(tableAndClass.targetTable.getPrimaryKey().getName()),
											new InsertExecutorITTest_autoGeneratedKeys.GeneratedKeysReaderAsInt(tableAndClass.targetTable.getPrimaryKey().getName()));
								}
								
							})
					.withPrimaryKeyFieldName("a");
		}
			
		@Test
		public void testInsert_generatedPK() throws Exception {
			// additional configuration for generated keys method capture
			when(connection.prepareStatement(anyString(), eq(Statement.RETURN_GENERATED_KEYS))).thenReturn(preparedStatement);
			
			// Implementing a ResultSet that gives results
			ResultSet generatedKeyResultSetMock = mock(ResultSet.class);
			when(preparedStatement.getGeneratedKeys()).thenReturn(generatedKeyResultSetMock);
			// the ResultSet instance will be called for all batch operations so values returned must reflect that
			when(generatedKeyResultSetMock.next()).thenReturn(true, true, true, false, true, false);
			when(generatedKeyResultSetMock.getInt(eq(1))).thenReturn(1, 2, 3, 4);
			// getObject is for null value detection, so values are not really important
			when(generatedKeyResultSetMock.getObject(eq(1))).thenReturn(1, 2, 3, 4);
			
			// we rebind statement argument capture because by default it's bound to the "non-generating keys" preparedStatement(..) signature 
			when(connection.prepareStatement(statementArgCaptor.capture(), eq(Statement.RETURN_GENERATED_KEYS))).thenReturn(preparedStatement);
			
			
			DMLGenerator dmlGenerator = new DMLGenerator(dialect.getColumnBinderRegistry(), new DMLGenerator.CaseSensitiveSorter());
			InsertExecutor<Toto> testInstance = new InsertExecutor<>(persistenceConfiguration.classMappingStrategy, transactionManager, dmlGenerator, Retryer.NO_RETRY, 3, 3);
			List<Toto> totoList = Arrays.asList(new Toto(17, 23), new Toto(29, 31), new Toto(37, 41), new Toto(43, 53));
			testInstance.insert(totoList);
			
			verify(preparedStatement, times(4)).addBatch();
			verify(preparedStatement, times(2)).executeBatch();
			verify(preparedStatement, times(8)).setInt(indexCaptor.capture(), valueCaptor.capture());
			assertEquals("insert into Toto(b, c) values (?, ?)", statementArgCaptor.getValue());
			PairSetList<Integer, Integer> expectedPairs = new PairSetList<Integer, Integer>()
					.of(1, 17).add(2, 23)
					.of(1, 29).add(2, 31)
					.of(1, 37).add(2, 41)
					.of(1, 43).add(2, 53);
			assertCapturedPairsEqual(expectedPairs);
			
			verify(generatedKeyResultSetMock, times(6)).next();
			verify(generatedKeyResultSetMock, times(4)).getInt(eq(1));
			
			// Verfy that database generated keys were set into Java instances
			int i = 1;
			for (Toto toto : totoList) {
				assertEquals(i++, (int) toto.a);
			}
		}
		
		protected static class PrimaryKeyReaderFromGeneratedKeys implements AfterInsertIdentifierGenerator {
			
			private final String primaryKeyName;
			
			protected PrimaryKeyReaderFromGeneratedKeys(String primaryKeyName) {
				this.primaryKeyName = primaryKeyName;
			}
			
			@Override
			public Serializable get(Map<String, Object> generatedKeys) {
				return (Serializable) generatedKeys.get(primaryKeyName);
			}
			
			@Override
			public void configure(Map<String, Object> configuration) {
				
			}
		}
	}	
}